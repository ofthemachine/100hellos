---
title: Complete Guide to Adding Languages to 100hellos
description: Consolidated, definitive guide for adding new programming languages to 100hellos, merging all requirements, processes, and best practices
tags:
    - project:100hellos
    - scope:languages
    - security:best-practice
    - type:recipe
---
# Complete Guide to Adding Languages to 100hellos

This is the definitive guide for adding new programming languages to the 100hellos project, consolidating all requirements, processes, and best practices.

## Pre-Addition: Mandatory Verification

**CRITICAL**: Before implementing any language, you MUST verify it doesn't already exist using the methodical verification process outlined in `must/methodical-language-verification`.

## Core Requirements

### 1. The "Hello World!" String
The output of your program **MUST** be exactly `Hello World!` (not `Hello, World!` or any other variation).

### 2. Authentic Implementation
Must use real language interpreters/compilers - no fake or shell script simulations.

### 3. MUSL Compatibility
Prioritize MUSL-compatible languages for Alpine Linux base compatibility.

## Implementation Process

### 1. Bootstrap the Language
```bash
make new HELLO=[lang]
```
This command:
- Creates the language directory structure
- Automatically decrements the counter in root README.md
- **CRITICAL**: Never manually modify the counter - let `make new` handle it

### 2. Configure Build and Run Process

Your goal is to provide an executable that the base container's `entrypoint.sh` can run.

#### Pattern A: Interpreted Languages (Shebang)
For languages like Python, Ruby, Janet:

1. **`[lang]/Dockerfile`**: Install language runtime, **no CMD**
2. **`[lang]/files/hello-world.[ext]`**: Code with proper shebang

Example:
```python
#!/usr/bin/env python3
print("Hello World!")
```

#### Pattern B: Compiled Languages (hello-world.sh)
For languages like Rust, Go, C++:

1. **`[lang]/Dockerfile`**: Install compiler, **no CMD**
2. **`[lang]/files/hello-world.sh`**: Script that compiles and runs
3. **`[lang]/files/hello-world.[ext]`**: Source code without shebang

Example hello-world.sh:
```bash
#!/bin/sh
rustc /hello-world/hello-world.rs -o /tmp/hello
/tmp/hello
```

### 3. Check Base Images Before Adding Dependencies

**CRITICAL**: Before adding any packages, check what's already available in the base image to avoid redundant installations.

#### Check Base Image Contents
```bash
# Check what packages/tools are already available
docker run --rm --entrypoint="" 100hellos/000-base:local zsh -c "which wget tar make git curl"

# Check specific base image contents
cat .base/Dockerfile
```

#### Common Tools Already in Base Images
The following are typically already available and should **NOT** be reinstalled:
- `wget`, `curl` - for downloading
- `tar`, `unzip` - for extracting archives
- `git` - version control
- `make` - build tool
- `zsh`, `sudo` - shell and privilege escalation

#### Example: Good vs Bad Dockerfile Practices
```dockerfile
# ❌ BAD: Redundant packages already in base
RUN sudo apk add --no-cache wget tar build-base go

# ✅ GOOD: Only install what's actually needed
RUN sudo apk add --no-cache go
```

### 4. Use Appropriate Base Images
- Use language-specific base images when possible (e.g., `100hellos/300-node:local`)
- **DO NOT** reinstall common utilities already in base images

### 5. Test Implementation
```bash
make [lang] R=1
```
Verify exact "Hello World!" output.

### 6. Documentation Requirements

#### Create README.md
Every language **MUST** include a README.md following these guidelines:

**Focus on language-specific content only**:
- Language description and unique features
- Interesting facts about the language
- Explanation of non-obvious "Hello World!" code
- Language history or notable characteristics
- Suggestions for further exploration

**Avoid redundant content**:
- Docker run commands (handled by overview template)
- Generic container usage instructions
- Redundant build/run information

#### Test All Documentation Examples
**CRITICAL**: Test every example in your README within the actual container environment:

```bash
# Test examples interactively
docker run --rm --entrypoint="" -it 100hellos/[lang]:local zsh

# Or test specific commands
docker run --rm --entrypoint="" 100hellos/[lang]:local [command]
```

All examples must work in the container environment before committing.

### 7. Clean Up Template Files
Remove all unused template files created by `make new`:
- `artifacts/` directory (if unused)
- Placeholder `files/hello-world.sh` script (if unused)
- Placeholder `files/hello-world.lang` file
- `README.scaffolding` file

## Git Commit Process

### 1. Always Include Root README.md
**CRITICAL**: The `make new` command modifies root README.md (decrements counter). This file MUST be committed along with your language files.

### 2. Use Single Quotes for Commit Messages
- ✅ `git commit -m 'Language says Hello!'`
- ❌ `git commit -m "Language says Hello!"` (can cause shell hanging)

### 3. Follow Creative Commit Style
Format: `[Language] [creative verb] Hello!`

Examples:
- `Janet says Hello!`
- `Zombie moans Hellllllo!`
- `Ballerina pirouettes Hello!`

## Common Pitfalls

1. **Silent Validation Failure**: Empty placeholder `hello-world.sh` left behind
2. **"too many arguments" Error**: Multiple `hello-world.*` files match the glob
3. **Forgetting root README.md**: Always commit the decremented counter
4. **Manual counter modification**: Let `make new` handle counter automatically
5. **Untested documentation**: Examples that don't work in container environment
6. **Double-quote commit issues**: Use single quotes to avoid shell problems
7. **Redundant package installation**: Adding packages already in base images
8. **Missing dependency research**: Not checking if a language requires specific toolchains

## Rollback Procedure

If you need to back out a failed language implementation:
1. Revert the language directory: `rm -rf [lang]/`
2. **Also revert root README.md**: `git checkout HEAD -- README.md`
3. Both changes happened during `make new` and both need reverting

## Security and Complex Builds

- **Version Pinning**: Always pin specific versions
- **Checksum Verification**: Verify downloads with checksums
- **Proper Ownership**: Use `COPY --chown=human:human`
- **Artifacts Pattern**: Valid for caching complex builds, but no CMD in Dockerfile

## Complete Workflow Summary

1. **Verify** language doesn't exist (`must/methodical-language-verification`)
2. **Bootstrap** with `make new HELLO=[lang]`
3. **Check base images** for existing packages before adding dependencies
4. **Implement** Dockerfile and source code (only adding necessary packages)
5. **Test** with `make [lang] R=1`
6. **Document** with comprehensive README.md
7. **Test documentation** examples in container
8. **Clean up** unused template files
9. **Commit** with creative message including root README.md

This consolidated guide replaces the need for multiple separate language addition documents and provides the complete, authoritative process.
